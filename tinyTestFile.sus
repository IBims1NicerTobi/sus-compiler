
module test<T> : ::int::<beep = 20 > 3; BEEP = int::<;>> ab {
	input gen int MY_INPUT

	MY_INPUT = 3

	input int beep

	beep = 3

	stlFIFO::<BITWIDTH = 4;> badoop
}

module use_test {
	test::<3;> test_mod


}

module stlFIFO {
	input gen int BITWIDTH// = 20
	input gen int DEPTH// = 512
	// The FIFO may still receive data for 5 cycles after ready is de-asserted
	input gen int ALMOST_FULL_THRESHOLD// = 5
	
	state bool[BITWIDTH][DEPTH] mem
	state int read_addr
	state int write_addr

	initial read_addr = 0
	initial write_addr = 0

	interface push : bool push'ALMOST_FULL_THRESHOLD, bool[BITWIDTH] data_in
	
	output bool ready'0

	interface pop : bool pop -> bool data_valid, bool[BITWIDTH] data_out
	
	cross_int write_to_pop
	write_to_pop.i = write_addr

	cross_int read_to_push
	read_to_push.i = read_addr

	cross_memory mem_to_pop
	mem_to_pop.i = mem

	if pop {
		data_valid = read_addr != write_to_pop.o
		if data_valid {
			// Add some pipelining registers, just because we can
			reg reg data_out = mem_to_pop.o[read_addr]
			read_addr = (read_addr + 1) % DEPTH
		}
	}

	if push {
		mem[write_addr] = data_in
		write_addr = (write_addr + 1) % DEPTH
	}
	
	// Wrapping subtract
	int space_remaining = (read_to_push.o - write_addr) % DEPTH
	bool r = space_remaining > ALMOST_FULL_THRESHOLD
	ready = offset_backwards(r)
}


module tinyTestMod : -> int o {
	input gen int beep

	o = beep
}


module testTinyTestMod {
	tinyTestMod::<beep = 3;> a
	tinyTestMod::<beep = 4;> b
	tinyTestMod::<beep = 3;> c
}
