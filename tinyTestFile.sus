
module test<T> : ::int::<beep = 20 > 3; BEEP = int::<;>> ab {
	input gen int MY_INPUT

	MY_INPUT = 3

	input int beep

	beep = 3

	stlFIFO::<BITWIDTH = 4;> badoop
}

module use_test {
	test::<3;> test_mod


}

module stlFIFO {
	input gen int BITWIDTH// = 20
	input gen int DEPTH// = 512
	// The FIFO may still receive data for 5 cycles after ready is de-asserted
	input gen int ALMOST_FULL_THRESHOLD// = 5
	
	state bool[BITWIDTH][DEPTH] mem
	state int read_addr
	state int write_addr

	initial read_addr = 0
	initial write_addr = 0

	interface push : bool push'ALMOST_FULL_THRESHOLD, bool[BITWIDTH] data_in
	
	output bool ready'0

	interface pop : bool pop -> bool data_valid, bool[BITWIDTH] data_out
	
	cross_int write_to_pop
	write_to_pop.i = write_addr

	cross_int read_to_push
	read_to_push.i = read_addr

	cross_memory mem_to_pop
	mem_to_pop.i = mem

	if pop {
		data_valid = read_addr != write_to_pop.o
		if data_valid {
			// Add some pipelining registers, just because we can
			reg reg data_out = mem_to_pop.o[read_addr]
			read_addr = (read_addr + 1) % DEPTH
		}
	}

	if push {
		mem[write_addr] = data_in
		write_addr = (write_addr + 1) % DEPTH
	}
	
	// Wrapping subtract
	int space_remaining = (read_to_push.o - write_addr) % DEPTH
	bool r = space_remaining > ALMOST_FULL_THRESHOLD
	ready = offset_backwards(r)
}


module tinyTestMod : -> int o {
	input gen int beep

	o = beep
}


module testTinyTestMod {
	tinyTestMod::<beep = 3;> a
	tinyTestMod::<beep = 4;> b
	tinyTestMod::<beep = 3;> c
}



module tree_add {
	input gen int WIDTH

	input int[WIDTH] values
	output int sum

	if WIDTH == 1 {
		sum = values[0]
	} else {
		gen int HALF_WIDTH = WIDTH / 2
		tree_add::<HALF_WIDTH;> left
		tree_add::<HALF_WIDTH;> right

		for int i in 0..HALF_WIDTH {
			left.values[i] = values[i]
			right.values[i] = values[i+HALF_WIDTH]
		}

		if WIDTH % 2 == 0 {
			reg sum = left.sum + right.sum
		} else {
			reg sum = left.sum + right.sum + values[WIDTH - 1]
		}
	}
}

module make_tree_add {
	gen int SIZE = 255

	int[SIZE] vs

	for int i in 0..SIZE {
		vs[i] = i
	}

	tree_add::<SIZE;> tr

	tr.values = vs

	output int beep = tr.sum
}


module replicate<T> {
	input gen int NUM_REPLS

	input T data

	output T[NUM_REPLS] result

	for int i in 0..NUM_REPLS {
		result[i] = data
	} 
}

module use_replicate {
	replicate::<NUM_REPLS = 50; T = bool> a
	replicate::<NUM_REPLS = 20; T = int[30]> b
}

module permute_t<T> {
	input gen int SIZE

	input gen int[SIZE] SOURCES

	interface permute : T[SIZE] d_in -> T[SIZE] d_out

	for int i in 0..SIZE {
		d_out[i] = d_in[SOURCES[i]]
	}
}

module use_permute<CheckT> {
	gen int[8] indices

	indices[0] = 3
	indices[1] = 2
	indices[2] = 4
	indices[3] = 5
	indices[4] = 1
	indices[5] = 2
	indices[6] = 7
	indices[7] = 6


	int[2] inArr

	inArr[0] = 2387
	inArr[1] = 786823

	permute_t::<SIZE = 8, SOURCES = indices; T = int> permut

	int[8] beep = permut.permute(indices)
}

module use_use_permute {
	use_permute::<; bool[3][17]> b
}
