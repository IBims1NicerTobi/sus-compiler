#![doc = include_str!("../README.md")]

mod alloc;
mod util;

mod config;
mod debug;
mod errors;
mod file_position;
mod flattening;
mod instantiation;
mod prelude;
mod to_string;
mod typing;
mod value;

mod codegen_fallback;

mod dev_aid;
mod linker;

mod compiler_top;

use std::path::PathBuf;
use std::{error::Error, fs};
use std::fs::File;
use std::io::Write;
use std::ops::Deref;
use std::rc::Rc;

use prelude::*;

use codegen_fallback::gen_verilog_code;
use config::{config, parse_args};
use dev_aid::ariadne_interface::*;
use flattening::Module;
use instantiation::InstantiatedModule;

fn codegen_instance(inst: &InstantiatedModule, md: &Module, out_file: &mut File) {
    let inst_name = &inst.name;
    if inst.errors.did_error {
        println!("Instantiating error: {inst_name}");
        return; // Continue
    }
    println!("Instantiating success: {inst_name}");
    let code = gen_verilog_code(md, &inst, true);
    write!(out_file, "// {inst_name}\n{code}").unwrap();
}

fn make_output_file(name : &str) -> File {
    let mut path = PathBuf::with_capacity(name.len()+"verilog_output/.sv".len());
    path.push("verilog_output");
    fs::create_dir_all(&path).unwrap();
    path.push(name);
    path.set_extension("sv");
    let mut file = File::create(path).unwrap();

    file.write_fmt(format_args!("// DO NOT EDIT THIS FILE\n// This file was generated with SUS Compiler {}", std::env!("CARGO_PKG_VERSION"))).unwrap();
    
    file
}

fn codegen_to_file(md: &Module) {
    let mut out_file = make_output_file(md.link_info.name.deref());
    md.instantiations.for_each_instance(|_template_args, inst| {
        codegen_instance(inst.as_ref(), md, &mut out_file)
    });
}

fn codegen_with_dependencies(linker: &Linker, md: &Module, file_name: &str) {
    let mut out_file = make_output_file(file_name);
    let mut top_level_instances: Vec<Rc<InstantiatedModule>> = Vec::new();
    md.instantiations.for_each_instance(|_template_args, inst| {
        top_level_instances.push(inst.clone());
    });
    let mut to_process_queue: Vec<(&InstantiatedModule, &Module)> = top_level_instances
        .iter()
        .map(|v| (v.as_ref(), md))
        .collect();

    let mut cur_idx = 0;

    while cur_idx < to_process_queue.len() {
        let (cur_instance, cur_md) = to_process_queue[cur_idx];

        for (_, sub_mod) in &cur_instance.submodules {
            let new_inst = sub_mod.instance.as_ref().unwrap().as_ref();

            // Skip duplicates
            // Yeah yeah I know O(nÂ²) but this list shouldn't grow too big. Fix if needed
            if to_process_queue
                .iter()
                .any(|existing| std::ptr::eq(existing.0, new_inst))
            {
                continue;
            }

            to_process_queue.push((new_inst, &linker.modules[sub_mod.module_uuid]));
        }

        codegen_instance(cur_instance, cur_md, &mut out_file);

        cur_idx += 1;
    }
}

fn main() -> Result<(), Box<dyn Error + Sync + Send>> {
    let file_paths = parse_args();

    let config = config();

    if config.use_lsp {
        #[cfg(feature = "lsp")]
        return dev_aid::lsp::lsp_main();

        #[cfg(not(feature = "lsp"))]
        panic!("LSP not enabled!")
    }

    let (linker, mut paths_arena) = compile_all(file_paths);
    print_all_errors(&linker, &mut paths_arena);

    if config.codegen {
        for (_id, md) in &linker.modules {
            codegen_to_file(md);
        }
    }

    if let Some(md_name) = &config.codegen_module_and_dependencies_one_file {
        let Some(md) = linker
            .modules
            .iter()
            .find(|(_, md)| &md.link_info.name == md_name) else {
            
            let mut err_lock = std::io::stderr().lock();
            writeln!(err_lock, "Unknown module {md_name}").unwrap();
            std::process::exit(1);
        };

        codegen_with_dependencies(&linker, md.1, &format!("{md_name}_standalone"));
    }

    Ok(())
}
