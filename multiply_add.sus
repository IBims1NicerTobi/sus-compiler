

template<int Size>
module ExactlyOne : bool[Size] inputs -> bool exactlyOne {
	if Size == 0 {
		exactlyOne = false;
	} else if Size == 1 {
	    exactlyOne = inputs[0];
	} else {
	    bool[Size] atLeastOnes;
		bool[Size] atLeastTwos;
		atLeastOnes[0] = inputs[0];
		atLeastTwos[0] = false;
		for i : 1..Size {
			atLeastOnes[i] = atLeastOnes[i-1] | inputs[i];
			atLeastTwos[i] = atLeastTwos[i-1] | atLeastOnes[i-1] & inputs[i];
		}
		exactlyOne = atLeastOnes & !atLeastTwos;
	}
}

module multiply_add2 : int a, int b, int c -> int r {
    int tmp = a * b;
	@
	r = tmp + c;
}


/* a module to test the syntax */
module MultiplyAdd : i32 a, i32 b, i32 c -> i32 result {
	//module beelqzd 
	// temporary variable
	i32 tmp = a * b;
	result = tmp + cooo * 30 + 5;
	array_subscript = tmp;
	@
	int[5] myVar = {1,2,3,4,5};
	@
	{
		//[
		beep boop;
	}
}

module beep : i32 a {
	state i32 beep;

	beep = 5;
	# 
	beep = a;
	
}


module multiply_add : i32 a, i32 b, i32 c -> i32 result, double double_result {
	i32 tmp = a * b;
	@
	result = tmp + c;
	@
	double_result = cvt_to_double(result);
}

module blur : i32'0 a -> i32'1 result : timeline (a -> /) .. (a -> r)* {
	state prev = a;
	#
	loop {
		result = @@@@@@(a + prev) / 2; // pipeline stage
		prev = a;
		#   // timeline step
	}
}

module my_complex_operation : i32'0 a -> i32'9 result : timeline (a -> /) .. (a -> r)* {
	state prev'0 = a;
	state tmp2'6;
	#
	loop {
		tmp2 = @@@@@@(a + prev) / 2; // pipeline stage
		result = @@@(prev + tmp2);
		prev = a;
		#   // timeline step
	}
}

module seq_adder : i32'0 a -> i32'9 result : timeline (a -> /)* .. (/ -> r) {
	state sum = a;
	#
	loop {
		sum = @@(sum + a);
		#
	}
	result = sum;
}


