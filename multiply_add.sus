

module multiply_add2 : int a, int b, int c -> int r {
    int tmp = a * b;
	reg r = tmp + c;
}

template<int Size>
module ExactlyOne : bool[Size] inputs -> bool exactlyOne {
	if Size == 0 {
		exactlyOne = false;
	} else if Size == 1 {
	    exactlyOne = inputs[0];
	} else {
	    bool[Size] atLeastOnes;
		bool[Size] atLeastTwos;
		atLeastOnes[0] = inputs[0];
		atLeastTwos[0] = false;
		for i in 1:Size {
			atLeastOnes[i] = atLeastOnes[i-1] | inputs[i];
			atLeastTwos[i] = atLeastTwos[i-1] | atLeastOnes[i-1] & inputs[i];
		}
		exactlyOne = atLeastOnes & !atLeastTwos;
	}
}


module parallel_mul_add_reg : int a, int b -> int p, int q {
    reg int a2 = a * a;
	reg int a3 = a * a2 + 3;
	reg p = a * a3;

	reg int b2 = b + b;
	reg int b3 = b + b2;
	reg q = b + b3;

	// UTF-8 Characters support
	Lööwe 老虎;

	
}


/*
    a
	b
	c
	    tmp
	    result
*/

timeline (v v _ -> _) .. (_ _ v -> v)
module mul_add : int a, int b, int c -> int result {
	reg int tmp = a * b;
	result = tmp + c;
}




/* a module to test the syntax */
module MultiplyAdd : i32 a, i32 b, i32 c -> i32 result {
	// temporary variable
	i32 tmp = a * b;
	result = tmp + cooo * 30 + 5;
	array_subscript = tmp;
	{
		//[
		beep boop;
	}
	@
	int[5] myVar;
	myVar[0] = 0;
	myVar[1] = 1;
	myVar[2] = 2;
	myVar[3] = 3;
	myVar[4] = 4;
	@
}

module beep : i32 a {
	state i32 beep;

	beep = 5;
	# 
	beep = a;
	
}

timeline (a -> r) .. (/ -> r)
module dwiogo : bool[512] data -> bool[256] out {
    state bool[256] save = data[256:511];
	out = data[0:255];
	#
	out = save;
}



timeline (v -> v) .. (/ -> v) .. (/ -> v) .. (/ -> v)
module packer : T[256] data /* v _ _ _ */ -> T[64] out { /* v v v v */
    state bool[256] save = data[256:511];
	out = data[0:255];
	#
	out = save;
}


module multiply_add : i32 a, i32 b, i32 c -> i32 result, double double_result {
	i32 tmp = a * b;
	reg result = tmp + c;
	reg double_result = cvt_to_double(result);
}

timeline (a -> /) .. (a -> r)*
module blur : i32'0 a -> i32'1 result {
	state int prev = a;
	#
	loop {
		result = @@@@@@(a + prev) / 2; // pipeline stage
		prev = a;
		#   // timeline step
	}
}

timeline (a -> /) .. (a -> r)*
module my_complex_operation : i32'0 a -> i32'9 result {
	state prev'0 = a;
	state tmp2'6;
	#
	loop {
		tmp2 = @@@@@@(a + prev) / 2; // pipeline stage
		result = @@@(prev + tmp2);
		prev = a;
		#   // timeline step
	}
}

timeline (a -> /)* .. (/ -> r)
module seq_adder : i32 a -> i32 result {
	state int sum = a;
	#
	loop {
		sum = sum + a;
		#
	}
	result = sum;
}
